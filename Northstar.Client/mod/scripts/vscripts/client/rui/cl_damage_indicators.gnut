untyped
globalize_all_functions

const vector INCOMING_DAMAGE_TEXT_BEGIN_POS = <0.63, 0.5 - 0.3, 0>
float OUTGOING_DAMAGE_TEXT_STACKING_FADE_TIME = 0.5
float OUTGOING_DAMAGE_TEXT_STACKING_DURATION = 1.3
float OUTGOING_DAMAGE_TEXT_STACKING_STAY_TIME = 0.8
float OUTGOING_DAMAGE_TEXT_SMALL_FADE_TIME = 0.5

float INCOMING_DAMAGE_TEXT_STACKING_FADE_TIME = 0.5
float INCOMING_DAMAGE_TEXT_STACKING_DURATION = 1.3
float INCOMING_DAMAGE_TEXT_STACKING_STAY_TIME = 0.8

var lastOutgoingDamageTextRui = null
var stackingIncomingDamageTextRui = null
float lastIncomingDamageTextHitTime = -99.0
float accumulatedIncomingDamage = 0.0

vector msgPos = <0,0,0>
var aspectRatioFixTopo

struct OutgoingDamageData
{
	float damage
	int accumelatedHits
	float lastHitTime
	bool isLastHitCrit
	vector msgPos
}

struct 
{
	float previousProgressValue
	float fadeOutTime
	bool hasTakenDamage = false
	float barX
	float barY
	float bobFrequency
	float bobAmplitude
	float previousCameraPos
	float previousTime
} file

table<entity, OutgoingDamageData> damageIndicators

void function Cl_DamageIndicator_Init()
{
	foreach ( k, v in eDamageSourceId )
	{
		AddLocalPlayerTookDamageCallback( v, TitanPlayerTookDamage )
	}

	thread PilotDamageBar()

    float right = (GetScreenSize()[1] / 9.0) * 16.0
	float down = GetScreenSize()[1]
	float xOffset = (GetScreenSize()[0] - right) / 2
	aspectRatioFixTopo = RuiTopology_CreatePlane( <xOffset, 0, 0>, <right, 0, 0>, <0, down, 0>, false )
    thread Thread_StackingDamageFlyoutText()
}

void function PilotDamageBar()
{
	file.previousProgressValue = 1.0
	file.fadeOutTime = Time()
	file.previousTime = Time()

	for(;;)
	{
		entity player = GetLocalViewPlayer()

		if ( !GetConVarBool("show_healthbars") )
		{
			WaitFrame()
			continue
		}

		if ( !player )
		{
			WaitFrame()
			continue
		}

		entity cockpit = player.GetCockpit()

		if(!cockpit)
		{
			WaitFrame()
			continue
		}

		local panel = cockpit.e.mainVGUI.GetPanel()
		local healthProgressBar = HudElement( "healthProgressBar", panel )

		if ( !file.barX || !file.barY )
		{
			local position = healthProgressBar.GetPos()

			file.barX = expect float( position[0].tofloat() )
			file.barY = expect float( position[1].tofloat() )
			WaitFrame()
			continue
		}

		if ( player.IsTitan() || clGlobal.isMenuOpen )
    	{
			healthProgressBar.Hide()
			WaitFrame() 
			continue
		}

		if( !IsAlive( player ) )
		{
			file.hasTakenDamage = false;
			healthProgressBar.Hide()
			WaitFrame() 
			continue
		}


		float currentHealth = player.GetHealth().tofloat()
		float maxHealth = player.GetMaxHealth().tofloat()

		float progressValue = ( currentHealth / maxHealth )
		float lerpSpeed = 0.1;
		float lerpedValue = file.previousProgressValue + lerpSpeed * ( progressValue - file.previousProgressValue )

		if( ( currentHealth < maxHealth ) && ( currentHealth > 0 ) )
		{
			file.hasTakenDamage = true;

			healthProgressBar.Show() 
			healthProgressBar.SetAlpha( 255 )
			file.fadeOutTime = Time()
		}

		healthProgressBar.SetBarProgress( lerpedValue )

		file.previousProgressValue = progressValue

		if( Time() - file.fadeOutTime >= 2.0  )
		{
			thread HealthFadeoutThread()
		}
		WaitFrame()
	}
}

void function HealthFadeoutThread()
{
	entity player = GetLocalViewPlayer()
	entity cockpit = player.GetCockpit()
	local panel = cockpit.e.mainVGUI.GetPanel()
	local healthProgressBar = HudElement( "healthProgressBar", panel )
	if( file.fadeOutTime >= 2.0 )
		healthProgressBar.FadeOverTime( 0, 0.2 )

	wait 0.2

	if( file.fadeOutTime >= 2.0 && IsValid( cockpit ) )
		healthProgressBar.Hide()
}

void function TitanPlayerTookDamage( float damage, vector pos, int damageType, int damageSourceId, entity attacker )
{
	if (!GetLocalViewPlayer().IsTitan())
        return

    if ( GetConVarInt( "damage_indicators_mode") == 1 || GetConVarInt( "damage_indicators_mode") == 3 )
    {
	    if (Time() - lastIncomingDamageTextHitTime > 0.75)
	    	accumulatedIncomingDamage = damage
	    else accumulatedIncomingDamage += damage
	    lastIncomingDamageTextHitTime = Time() // :D
	        RuiSetString( stackingIncomingDamageTextRui, "msgText", format( "-%i", int( accumulatedIncomingDamage ) ) )
    }
}

void function CreateStackingDamageFlyout( entity s, float damage, bool isCrit, vector msgPos )
{
	var rui = RuiCreate( $"ui/cockpit_console_text_top_left.rpak", aspectRatioFixTopo, RUI_DRAW_HUD, 0)
	RuiSetInt( rui, "maxLines", 1 );
	RuiSetInt( rui, "lineNum", 0 );
	RuiSetFloat2( rui, "msgPos", WorldToScreenPos(msgPos) - <0, 0.01, 0> )
	RuiSetString( rui, "msgText",  RecursiveCommas(damage.tointeger()) )
	RuiSetFloat3( rui, "msgColor", isCrit ? <0.9, 0.55, 0.3> : <0.9, 0.9, 0.9> )
	RuiSetFloat( rui, "msgFontSize", 36.0)
	RuiSetFloat( rui, "msgAlpha", 0.9 )
	RuiSetFloat( rui, "thicken", 0.0 )

	OutgoingDamageData data
	data.damage = damage
	data.isLastHitCrit = isCrit
	data.accumelatedHits = 1
	data.msgPos = msgPos
	data.lastHitTime = Time()
	damageIndicators[s] <- data

	while (Time() - data.lastHitTime <= OUTGOING_DAMAGE_TEXT_STACKING_STAY_TIME + OUTGOING_DAMAGE_TEXT_STACKING_FADE_TIME)
	{
		RuiSetString( rui, "msgText", RecursiveCommas(data.damage.tointeger()) )
		RuiSetFloat2( rui, "msgPos", WorldToScreenPos(data.msgPos) - <0.0, 0.01, 0> )
		RuiSetFloat( rui, "msgAlpha", GraphCapped( Time() - data.lastHitTime, OUTGOING_DAMAGE_TEXT_STACKING_STAY_TIME, 
			OUTGOING_DAMAGE_TEXT_STACKING_STAY_TIME + OUTGOING_DAMAGE_TEXT_STACKING_FADE_TIME, 0.9, 0.0 ) )
		RuiSetFloat3( rui, "msgColor", data.isLastHitCrit ? <0.9, 0.55, 0.3> : <0.9, 0.9, 0.9> )
		WaitFrame()
	}
	RuiDestroyIfAlive(rui)
	delete damageIndicators[s]
}

void function AddSmallDamageTextFlyout(float damage, bool isCrit, vector msgPos)
{
	var rui = RuiCreate( $"ui/cockpit_console_text_top_left.rpak", aspectRatioFixTopo, RUI_DRAW_HUD, 0)
	RuiSetInt( rui, "maxLines", 1 );
	RuiSetInt( rui, "lineNum", 0 );
	RuiSetFloat2( rui, "msgPos", WorldToScreenPos(msgPos) - <0, 0.01, 0> )
	RuiSetString( rui, "msgText",  RecursiveCommas(damage.tointeger()) )
	RuiSetFloat3( rui, "msgColor", isCrit ? <0.9, 0.55, 0.3> : <0.9, 0.9, 0.9> )
	RuiSetFloat( rui, "msgFontSize", 24.0)
	RuiSetFloat( rui, "msgAlpha", 0.5 )
	RuiSetFloat( rui, "thicken", 0.0 )

	float startTime = Time()
	
	while ( Time() - startTime < OUTGOING_DAMAGE_TEXT_SMALL_FADE_TIME )
	{
		float alpha = Graph( Time() - startTime, 0, OUTGOING_DAMAGE_TEXT_SMALL_FADE_TIME, 0.5, 0 )
		vector posOffset = <0, 0.01, 0>
		posOffset.y += Graph( Time() - startTime, 0, OUTGOING_DAMAGE_TEXT_SMALL_FADE_TIME, 0, -0.05 )
		RuiSetFloat( rui, "msgAlpha", alpha )
		RuiSetFloat2( rui, "msgPos", WorldToScreenPos(msgPos) + posOffset )
		WaitFrame()
	}
	RuiDestroyIfAlive(rui)
}

void function Thread_StackingDamageFlyoutText()
{
	// incoming damage text
	stackingIncomingDamageTextRui = RuiCreate( $"ui/cockpit_console_text_top_left.rpak", aspectRatioFixTopo, RUI_DRAW_HUD, 1)
	RuiSetInt( stackingIncomingDamageTextRui, "maxLines", 1 );
	RuiSetInt( stackingIncomingDamageTextRui, "lineNum", 0 );
	RuiSetFloat2( stackingIncomingDamageTextRui, "msgPos", INCOMING_DAMAGE_TEXT_BEGIN_POS )
	RuiSetFloat( stackingIncomingDamageTextRui, "thicken", 0.0 )
	RuiSetFloat( stackingIncomingDamageTextRui, "msgFontSize", 40.0)
	RuiSetFloat3( stackingIncomingDamageTextRui, "msgColor", <0.85, 0.0, 0.0> )
	RuiSetFloat( stackingIncomingDamageTextRui, "msgAlpha", 0.9 )
	RuiSetFloat( stackingIncomingDamageTextRui, "thicken", 0.0 )

	while (true)
	{
		if (IsValid(GetLocalViewPlayer()))
		{
			INCOMING_DAMAGE_TEXT_STACKING_FADE_TIME = 0.25
			INCOMING_DAMAGE_TEXT_STACKING_DURATION = 1.0
			INCOMING_DAMAGE_TEXT_STACKING_STAY_TIME = INCOMING_DAMAGE_TEXT_STACKING_DURATION - INCOMING_DAMAGE_TEXT_STACKING_FADE_TIME

			OUTGOING_DAMAGE_TEXT_STACKING_FADE_TIME = 0.25
			OUTGOING_DAMAGE_TEXT_STACKING_DURATION = 1.0
			OUTGOING_DAMAGE_TEXT_STACKING_STAY_TIME = OUTGOING_DAMAGE_TEXT_STACKING_DURATION - OUTGOING_DAMAGE_TEXT_STACKING_FADE_TIME
			
			// incoming damage text update
			
			float timeSinceLastHit = Time() - lastIncomingDamageTextHitTime
			float alpha = GraphCapped( timeSinceLastHit - INCOMING_DAMAGE_TEXT_STACKING_STAY_TIME, 0, INCOMING_DAMAGE_TEXT_STACKING_FADE_TIME, 0.9, 0)
			RuiSetFloat( stackingIncomingDamageTextRui, "msgAlpha", alpha )
			switch (GetLocalViewPlayer().GetPlayerModHealth())
			{
				case 12500:
				case 9000:
					// 5 segments - 1500 per segment for BT, 2500 for legion/scorch
					RuiSetFloat2( stackingIncomingDamageTextRui, "msgPos", INCOMING_DAMAGE_TEXT_BEGIN_POS + <0.035, 0, 0> )
					break;
				case 10000:
					RuiSetFloat2( stackingIncomingDamageTextRui, "msgPos", INCOMING_DAMAGE_TEXT_BEGIN_POS )
					break;
				case 7500:
					RuiSetFloat2( stackingIncomingDamageTextRui, "msgPos", INCOMING_DAMAGE_TEXT_BEGIN_POS - <0.035, 0, 0> )
					break;
			}
		}

		WaitFrame()
	}
}

vector function WorldToScreenPos( vector position )
{
    var res = Hud.ToScreenSpace( position )

    array pos = expect array( res )

	float aspectRatio = GetScreenSize()[0] / GetScreenSize()[1]
	float targetAspectRatio = 1.77777778

    vector result = <float( pos[0] ) / GetScreenSize()[0] / aspectRatio * targetAspectRatio, float( pos[1] ) / GetScreenSize()[1], 0 >
    //print(result)
    return result
}

string function RecursiveCommas(int n, bool recursed = false)
{
    int rest = n % 1000; //"last 3 digits"
    n /= 1000;  

    if (n > 0) {
        return RecursiveCommas(n) + "," + format( "%03i", rest ); //printing "begining"
    }
    
    return rest.tostring(); //first chunk of the number
}
void function PlayerDidDamageText( float damage, vector damagePosition, entity victim, bool isCrit, bool isIneffective )
{
    if( !GetLocalClientPlayer().IsTitan() )
        return

	if ( !victim.IsTitan() )
		return

    if( GetConVarInt( "damage_indicators_mode" ) >= 2 )
    {
	    float damageScale = 1.0
	    msgPos = victim.GetOrigin() + <0,0,victim.GetBoundingMaxs().z>
	    damageScale *= CalculateDivisorForEntity(victim)

	    thread AddSmallDamageTextFlyout( damage * damageScale, isCrit, msgPos )
    
	    if (victim in damageIndicators)
	    {
	    	OutgoingDamageData data = damageIndicators[victim]
	    	data.lastHitTime = Time()
	    	data.damage += damage * damageScale
	    	data.isLastHitCrit = isCrit
	    	data.msgPos = msgPos
	    }
	    else 
	    {
	    	thread CreateStackingDamageFlyout( victim, damage * damageScale, isCrit, msgPos )
	    }
    }
}

float function CalculateDivisorForEntity( entity npc )
{
	return 1.0
}	